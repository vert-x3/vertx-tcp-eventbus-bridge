= Vert.x-tcp-eventbus-bridge
:toc: left

Vert.x-tcp-eventbus-bridge is a bridge to Vert.x EventBus. To use this project, add the following
dependency to the _dependencies_ section of your build descriptor:

Maven (in your `pom.xml`):

[source,xml,subs="+attributes"]
----
<dependency>
  <groupId>${maven.groupId}</groupId>
  <artifactId>${maven.artifactId}</artifactId>
  <version>${maven.version}</version>
</dependency>
----

Gradle (in your `build.gradle` file):

[source,groovy,subs="+attributes"]
----
compile '${maven.groupId}:${maven.artifactId}:${maven.version}'
----

The TCP EventBus bridge is built on top of TCP, meaning that any application that can
create TCP sockets can interact with a remote Vert.x instance via its event bus.

The main use case for the TCP bridge _versus_ the SockJS bridge is for applications that are more
resource-constrained and that need to be lightweight since the whole SockJS is replaced with plain sockets.

It remains of course useful even for applications that don't have tight resource constraints:
the protocol is simple enough to efficiently provide an integration interface with non-JVM
applications.

== JSON-RPC2

The current bridge is designed around https://www.jsonrpc.org/specification[json-rpc2]. This allows developers to connect from any platform or programming language with support for this simple format.

JSON-RPC is a stateless, light-weight remote procedure call (RPC) protocol. This means that concepts such as `client` or `server` are not defined. In fact an application communicating using JSON-RPC can act as:

1. client
2. server
3. client-and-server

=== JSON-RPC and TCP Sockets

The first mode of operations for the bridge is to allow straight forward communication between two applicatitons capable of doing simple TCP socket connections.

First start by creating a bridge in vert.x and allow communications to the `in` and `out` addresses:

[source,$lang]
----
{@link examples.TCPBridgeExamples#example2}
----

You can test the application by writing to the socket directly from your terminal:

[source,bash]
----
echo '{"jsonrpc":"2.0","method":"send","id":"1","params":{"address":"in","body":"Hello World!"}}' |\
netcat localhost 7000
----

Or using a favourite json-rpc library of your choice.

=== JSON-RPC and Web-Sockets

The bridge can work exaclty the same way as with TCP, but using WebSockets instead. The use is very similar:

[source,$lang]
----
{@link examples.WebsocketBridgeExample#example1}
----

This example may resemble more complex, but in fact it is very similar to the previous one. The major differences are that, with websockets, a http server must be created and a protocol upgrade should be put in place to upgrade from HTTP to WS. The upgrade should happen at a well known path (omitted in the example for brevity).

The second difference is that we allow both text or binary WS frames (as configured in the options). This is to allow all kinds of integrations. For simple HTML integrations, text frames can be simpler to use, but nothing really forbids its use from a browser either.

[source,html]
----
<html lang="en">
<head>
  <script type="text/javascript">
    let ws = new WebSocket('ws://localhost:8080/');

    ws.onmessage = (event) => {
      console.log("onmessage content: " + event.data);
    }

    async function sendMsg() {
      let message = document.getElementById("payload").value;
      ws.send(message);
    }
  </script>
</head>
<body>
 <input type="text" id="payload"
  value='{"jsonrpc":"2.0","method":"register","id":"2","params":{"address":"ping"}}'>
 <input type="button" onclick="sendMsg()" value="Send message"/>
</body>
</html>
----

=== JSON-RPC and HTTP

The previous transports allow bi-directional messaging, however HTTP is built on top of the request-response style of protocols. When using the bridge in this mode, only a single request can be performed per request. It should be very common to find this pattern on json-rpc libraries. The setup would be as:

[source,$lang]
----
{@link examples.HttpBridgeExample#example1}
----

Just like the previous example, the bridge should be used at a specific path, but this is omitted for brevity of the example.

=== JSON-RPC and HTTP SSE

HTTP also supports server sent events. In this mode a single request can receive a stream of responses. Due to the way SSE works, the stream is always from server to client. Our bridge also allows this by specifying the SSE mode:

TODO: This is still incomplete (API done but public interface missing).

== LEGACY TCP

Previously, the protocol was as simple as possible and communications used frames both ways.
The structure of a Frame looked like this:

----
<Length: uInt32><{
   type: String,
   address: String,
   (replyAddress: String)?,
   headers: JsonObject,
   body: JsonObject
}: JsonObject>
----

The message consists of a JSON document that may or may not have been minified.
The message must be prefixed by a _big endian_ 32 bits positive integer (4 bytes) that indicates
the full length of the JSON document, in bytes.

The message `type` can be the following for messages sent by the TCP client:

1. `send` to send a message to an `address`,
2. `publish` to publish a message to an `address`,
3. `register` to subscribe to the messages sent or published to an `address`,
4. `unregister` to unsubscribe to the messages sent or published to an `address`,
5. `ping` to send a `ping` request to the bridge.

Note that the `replyAddress` field is optional and may only be used for a `send` message.
A message with that field is expected to _eventually_ receive a message back from the server
whose `address` field will be that of the original `replyAddress` value.

The server posts messages back to the client, and they can be of the following `type`:

1. `message` for messages sent or published to an `address`, or
2. `err` to indicate an error (the `body` shall contain details), or
3. `pong` to respond the `ping` request sent from client.

An example NodeJS client is available in the source of the project.
This client uses the same API as the SockJS
counter part so it should make it easier to switch between the TCP and SockJS implementations.

An example on how to get started with this bridge could be:

[source,$lang]
----
{@link examples.TCPBridgeExamples#example1}
----
